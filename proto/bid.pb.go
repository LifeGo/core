// Code generated by protoc-gen-go. DO NOT EDIT.
// source: bid.proto

/*
Package sonm is a generated protocol buffer package.

It is generated from these files:
	bid.proto
	capabilities.proto
	hub.proto
	insonmnia.proto
	miner.proto

It has these top-level messages:
	CPURequirements
	RAMRequirements
	DiskRequirements
	NetworkRequirements
	GPURequirements
	Container
	ContainerRequirements
	BidItem
	Capabilities
	CPUDevice
	RAMDevice
	GPUDevice
	ListRequest
	ListReply
	HubInfoRequest
	TaskRequirements
	HubStartTaskRequest
	HubStartTaskReply
	HubStatusMapRequest
	HubStatusRequest
	HubStatusReply
	SignContractRequest
	SignContractReply
	ExecContractRequest
	ExecContractReply
	PingRequest
	PingReply
	CPUUsage
	MemoryUsage
	NetworkUsage
	ResourceUsage
	InfoReply
	StopTaskRequest
	StopTaskReply
	TaskStatusRequest
	TaskStatusReply
	StatusMapReply
	ContainerRestartPolicy
	TaskLogsRequest
	TaskLogsChunk
	TaskResourceRequirements
	Timestamp
	MinerInfoRequest
	MinerHandshakeRequest
	MinerHandshakeReply
	MinerStartRequest
	MinerStartReply
	MinerStatusMapRequest
*/
package sonm

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// CPU requirements.
type CPURequirements struct {
	// CPU types acceptable. Empty list means any.
	Type []string `protobuf:"bytes,1,rep,name=type" json:"type,omitempty"`
	// CPU frequency minimum, measured in MHz.
	FreqMin int64 `protobuf:"varint,2,opt,name=freqMin" json:"freqMin,omitempty"`
	// CPU speed minimum, measured in some benchmark.
	SpeedMin int64 `protobuf:"varint,3,opt,name=speedMin" json:"speedMin,omitempty"`
	// CPU core count minimum.
	CoresMin int32 `protobuf:"varint,4,opt,name=coresMin" json:"coresMin,omitempty"`
}

func (m *CPURequirements) Reset()                    { *m = CPURequirements{} }
func (m *CPURequirements) String() string            { return proto.CompactTextString(m) }
func (*CPURequirements) ProtoMessage()               {}
func (*CPURequirements) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *CPURequirements) GetType() []string {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *CPURequirements) GetFreqMin() int64 {
	if m != nil {
		return m.FreqMin
	}
	return 0
}

func (m *CPURequirements) GetSpeedMin() int64 {
	if m != nil {
		return m.SpeedMin
	}
	return 0
}

func (m *CPURequirements) GetCoresMin() int32 {
	if m != nil {
		return m.CoresMin
	}
	return 0
}

// RAM requirements.
type RAMRequirements struct {
	// RAM types acceptable. Empty list means any.
	Type []string `protobuf:"bytes,1,rep,name=type" json:"type,omitempty"`
	// Number of RAM bytes minimum required.
	AmountMin int64 `protobuf:"varint,2,opt,name=amountMin" json:"amountMin,omitempty"`
}

func (m *RAMRequirements) Reset()                    { *m = RAMRequirements{} }
func (m *RAMRequirements) String() string            { return proto.CompactTextString(m) }
func (*RAMRequirements) ProtoMessage()               {}
func (*RAMRequirements) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *RAMRequirements) GetType() []string {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *RAMRequirements) GetAmountMin() int64 {
	if m != nil {
		return m.AmountMin
	}
	return 0
}

// Disk requirements.
type DiskRequirements struct {
	// Disk types acceptable. Empty list means any.
	Type []string `protobuf:"bytes,1,rep,name=type" json:"type,omitempty"`
	// Number of bytes minimum required.
	AmountMin int64 `protobuf:"varint,2,opt,name=amountMin" json:"amountMin,omitempty"`
	// Random read throughput minimum, measured in Kbytes/sec.
	ReadRandSpeedMin int64 `protobuf:"varint,3,opt,name=readRandSpeedMin" json:"readRandSpeedMin,omitempty"`
	// Random read throughput minimum, measured in IOPS.
	ReadRandIopsMin int64 `protobuf:"varint,4,opt,name=readRandIopsMin" json:"readRandIopsMin,omitempty"`
	// Random write throughput minimum, measured in Kbytes/sec.
	WriteRandSpeedMin int64 `protobuf:"varint,5,opt,name=writeRandSpeedMin" json:"writeRandSpeedMin,omitempty"`
	// Random write throughput minimum, measured in IOPS.
	WriteRandIopsMin int64 `protobuf:"varint,6,opt,name=writeRandIopsMin" json:"writeRandIopsMin,omitempty"`
	// I/O latency maximum, measured in microseconds.
	LatencyMax int64 `protobuf:"varint,7,opt,name=latencyMax" json:"latencyMax,omitempty"`
}

func (m *DiskRequirements) Reset()                    { *m = DiskRequirements{} }
func (m *DiskRequirements) String() string            { return proto.CompactTextString(m) }
func (*DiskRequirements) ProtoMessage()               {}
func (*DiskRequirements) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DiskRequirements) GetType() []string {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *DiskRequirements) GetAmountMin() int64 {
	if m != nil {
		return m.AmountMin
	}
	return 0
}

func (m *DiskRequirements) GetReadRandSpeedMin() int64 {
	if m != nil {
		return m.ReadRandSpeedMin
	}
	return 0
}

func (m *DiskRequirements) GetReadRandIopsMin() int64 {
	if m != nil {
		return m.ReadRandIopsMin
	}
	return 0
}

func (m *DiskRequirements) GetWriteRandSpeedMin() int64 {
	if m != nil {
		return m.WriteRandSpeedMin
	}
	return 0
}

func (m *DiskRequirements) GetWriteRandIopsMin() int64 {
	if m != nil {
		return m.WriteRandIopsMin
	}
	return 0
}

func (m *DiskRequirements) GetLatencyMax() int64 {
	if m != nil {
		return m.LatencyMax
	}
	return 0
}

// Internet connection requirements.
type NetworkRequirements struct {
	// Outbound throughput of Internet connection minimum, measured in Kbytes/sec.
	OutSpeedMin int64 `protobuf:"varint,1,opt,name=outSpeedMin" json:"outSpeedMin,omitempty"`
	// Inbound throughput of Internet connection minimum, measured in Kbytes/sec.
	InSpeedMin int64 `protobuf:"varint,2,opt,name=inSpeedMin" json:"inSpeedMin,omitempty"`
	// Round-trip latency to some public resource maximum, measured in ms. TODO: DOUBTFUL.
	// float networkLatencyMax = 3;
	// Flag to use "white IP" for incoming connections.
	WhiteIp bool `protobuf:"varint,4,opt,name=whiteIp" json:"whiteIp,omitempty"`
}

func (m *NetworkRequirements) Reset()                    { *m = NetworkRequirements{} }
func (m *NetworkRequirements) String() string            { return proto.CompactTextString(m) }
func (*NetworkRequirements) ProtoMessage()               {}
func (*NetworkRequirements) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *NetworkRequirements) GetOutSpeedMin() int64 {
	if m != nil {
		return m.OutSpeedMin
	}
	return 0
}

func (m *NetworkRequirements) GetInSpeedMin() int64 {
	if m != nil {
		return m.InSpeedMin
	}
	return 0
}

func (m *NetworkRequirements) GetWhiteIp() bool {
	if m != nil {
		return m.WhiteIp
	}
	return false
}

type GPURequirements struct {
	// GPU types acceptable. Empty list means any.
	Type []string `protobuf:"bytes,1,rep,name=type" json:"type,omitempty"`
	// RAM minimum, measured in Gbytes. TODO: WAT?
	RamMin int64 `protobuf:"varint,2,opt,name=ramMin" json:"ramMin,omitempty"`
	// Frequency minimum, measured in MHz
	FreqMin int64 `protobuf:"varint,3,opt,name=freqMin" json:"freqMin,omitempty"`
	// Shaders count minimum.
	ShadersMin int64 `protobuf:"varint,4,opt,name=shadersMin" json:"shadersMin,omitempty"`
	// Texture mapping unit count minimum.
	TmusMin int64 `protobuf:"varint,5,opt,name=tmusMin" json:"tmusMin,omitempty"`
	// Render output unit count minimum.
	RopsMin int64 `protobuf:"varint,6,opt,name=ropsMin" json:"ropsMin,omitempty"`
}

func (m *GPURequirements) Reset()                    { *m = GPURequirements{} }
func (m *GPURequirements) String() string            { return proto.CompactTextString(m) }
func (*GPURequirements) ProtoMessage()               {}
func (*GPURequirements) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *GPURequirements) GetType() []string {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *GPURequirements) GetRamMin() int64 {
	if m != nil {
		return m.RamMin
	}
	return 0
}

func (m *GPURequirements) GetFreqMin() int64 {
	if m != nil {
		return m.FreqMin
	}
	return 0
}

func (m *GPURequirements) GetShadersMin() int64 {
	if m != nil {
		return m.ShadersMin
	}
	return 0
}

func (m *GPURequirements) GetTmusMin() int64 {
	if m != nil {
		return m.TmusMin
	}
	return 0
}

func (m *GPURequirements) GetRopsMin() int64 {
	if m != nil {
		return m.RopsMin
	}
	return 0
}

type Container struct {
	// Docker registry URI.
	Registry string `protobuf:"bytes,1,opt,name=registry" json:"registry,omitempty"`
	// Container image name.
	Image string `protobuf:"bytes,2,opt,name=image" json:"image,omitempty"`
	// Auth info to a registry.
	Auth string `protobuf:"bytes,3,opt,name=auth" json:"auth,omitempty"`
}

func (m *Container) Reset()                    { *m = Container{} }
func (m *Container) String() string            { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()               {}
func (*Container) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Container) GetRegistry() string {
	if m != nil {
		return m.Registry
	}
	return ""
}

func (m *Container) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Container) GetAuth() string {
	if m != nil {
		return m.Auth
	}
	return ""
}

type ContainerRequirements struct {
	// Container specific information.
	Container *Container `protobuf:"bytes,1,opt,name=container" json:"container,omitempty"`
	// When a container should be run (hour-grained).
	StartTime *Timestamp `protobuf:"bytes,2,opt,name=startTime" json:"startTime,omitempty"`
	// When a container should to be stopped (hour-grained).
	EndTime *Timestamp `protobuf:"bytes,3,opt,name=endTime" json:"endTime,omitempty"`
	// Minimal scale factor for a container.
	CountMin int32 `protobuf:"varint,4,opt,name=countMin" json:"countMin,omitempty"`
	// Maximum scale factor for a container.
	CountMax int32 `protobuf:"varint,5,opt,name=countMax" json:"countMax,omitempty"`
	// Probability of node failure maximum.
	FailureMax float32 `protobuf:"fixed32,6,opt,name=failureMax" json:"failureMax,omitempty"`
	// Node availability minimum.
	AvailabilityMin float32 `protobuf:"fixed32,7,opt,name=availabilityMin" json:"availabilityMin,omitempty"`
	// Node rating minimum.
	RatingMin float32 `protobuf:"fixed32,8,opt,name=ratingMin" json:"ratingMin,omitempty"`
	// Price per hour maximum.
	// If omitted, the minimum price for matched node is used (market price),
	// or if node also asks for market price, the price is evaluated
	// automatically (TBD).
	PriceMax float32 `protobuf:"fixed32,9,opt,name=priceMax" json:"priceMax,omitempty"`
}

func (m *ContainerRequirements) Reset()                    { *m = ContainerRequirements{} }
func (m *ContainerRequirements) String() string            { return proto.CompactTextString(m) }
func (*ContainerRequirements) ProtoMessage()               {}
func (*ContainerRequirements) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ContainerRequirements) GetContainer() *Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *ContainerRequirements) GetStartTime() *Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *ContainerRequirements) GetEndTime() *Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *ContainerRequirements) GetCountMin() int32 {
	if m != nil {
		return m.CountMin
	}
	return 0
}

func (m *ContainerRequirements) GetCountMax() int32 {
	if m != nil {
		return m.CountMax
	}
	return 0
}

func (m *ContainerRequirements) GetFailureMax() float32 {
	if m != nil {
		return m.FailureMax
	}
	return 0
}

func (m *ContainerRequirements) GetAvailabilityMin() float32 {
	if m != nil {
		return m.AvailabilityMin
	}
	return 0
}

func (m *ContainerRequirements) GetRatingMin() float32 {
	if m != nil {
		return m.RatingMin
	}
	return 0
}

func (m *ContainerRequirements) GetPriceMax() float32 {
	if m != nil {
		return m.PriceMax
	}
	return 0
}

type BidItem struct {
	// List of records, each describing requirements to run one container.
	Containers []*ContainerRequirements `protobuf:"bytes,1,rep,name=containers" json:"containers,omitempty"`
}

func (m *BidItem) Reset()                    { *m = BidItem{} }
func (m *BidItem) String() string            { return proto.CompactTextString(m) }
func (*BidItem) ProtoMessage()               {}
func (*BidItem) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *BidItem) GetContainers() []*ContainerRequirements {
	if m != nil {
		return m.Containers
	}
	return nil
}

func init() {
	proto.RegisterType((*CPURequirements)(nil), "sonm.CPURequirements")
	proto.RegisterType((*RAMRequirements)(nil), "sonm.RAMRequirements")
	proto.RegisterType((*DiskRequirements)(nil), "sonm.DiskRequirements")
	proto.RegisterType((*NetworkRequirements)(nil), "sonm.NetworkRequirements")
	proto.RegisterType((*GPURequirements)(nil), "sonm.GPURequirements")
	proto.RegisterType((*Container)(nil), "sonm.Container")
	proto.RegisterType((*ContainerRequirements)(nil), "sonm.ContainerRequirements")
	proto.RegisterType((*BidItem)(nil), "sonm.BidItem")
}

func init() { proto.RegisterFile("bid.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 545 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0xcd, 0xae, 0xd2, 0x40,
	0x14, 0x4e, 0x29, 0x50, 0x7a, 0x58, 0xf4, 0x3a, 0xfe, 0x84, 0x5c, 0xcd, 0x0d, 0xe9, 0x0a, 0x8d,
	0xb2, 0xb8, 0x2e, 0x5d, 0x29, 0x46, 0xc3, 0x02, 0xa3, 0xa3, 0x3e, 0xc0, 0x40, 0xe7, 0xc2, 0x44,
	0x3a, 0x2d, 0x33, 0x53, 0x81, 0xf7, 0xf0, 0x2d, 0x7c, 0x25, 0x1f, 0xc6, 0x9c, 0x29, 0x9d, 0xb6,
	0x60, 0xa2, 0x89, 0x2b, 0xfa, 0xfd, 0xf4, 0xcc, 0x99, 0xaf, 0xe7, 0x00, 0xe1, 0x52, 0x24, 0xd3,
	0x5c, 0x65, 0x26, 0x23, 0x5d, 0x9d, 0xc9, 0xf4, 0x3a, 0x12, 0x12, 0x7f, 0xa5, 0x60, 0x25, 0x1d,
	0xef, 0x21, 0x9a, 0x7d, 0xfc, 0x4a, 0xf9, 0xae, 0x10, 0x8a, 0xa7, 0x5c, 0x1a, 0x4d, 0x08, 0x74,
	0xcd, 0x31, 0xe7, 0x23, 0x6f, 0xec, 0x4f, 0x42, 0x6a, 0x9f, 0xc9, 0x08, 0x82, 0x3b, 0xc5, 0x77,
	0x0b, 0x21, 0x47, 0x9d, 0xb1, 0x37, 0xf1, 0x69, 0x05, 0xc9, 0x35, 0x0c, 0x74, 0xce, 0x79, 0x82,
	0x92, 0x6f, 0x25, 0x87, 0x51, 0x5b, 0x65, 0x8a, 0x6b, 0xd4, 0xba, 0x63, 0x6f, 0xd2, 0xa3, 0x0e,
	0xc7, 0x33, 0x88, 0xe8, 0xeb, 0xc5, 0x5f, 0x0f, 0x7e, 0x02, 0x21, 0x4b, 0xb3, 0x42, 0x9a, 0xfa,
	0xe8, 0x9a, 0x88, 0x7f, 0x74, 0xe0, 0xea, 0xad, 0xd0, 0xdf, 0xfe, 0xaf, 0x0c, 0x79, 0x06, 0x57,
	0x8a, 0xb3, 0x84, 0x32, 0x99, 0x7c, 0x6e, 0xdf, 0xe5, 0x82, 0x27, 0x13, 0x88, 0x2a, 0x6e, 0x9e,
	0xe5, 0xee, 0x6a, 0x3e, 0x3d, 0xa7, 0xc9, 0x73, 0xb8, 0xb7, 0x57, 0xc2, 0xf0, 0x56, 0xd9, 0x9e,
	0xf5, 0x5e, 0x0a, 0xd8, 0x83, 0x23, 0xab, 0xc2, 0xfd, 0xb2, 0x87, 0x73, 0x9e, 0xdc, 0x00, 0x6c,
	0x99, 0xe1, 0x72, 0x75, 0x5c, 0xb0, 0xc3, 0x28, 0xb0, 0xae, 0x06, 0x13, 0xef, 0xe0, 0xfe, 0x07,
	0x6e, 0xf6, 0x99, 0x6a, 0x07, 0x33, 0x86, 0x61, 0x56, 0x18, 0xd7, 0x8a, 0x67, 0xdf, 0x6b, 0x52,
	0x58, 0x58, 0x48, 0x67, 0x28, 0x73, 0x6a, 0x30, 0x38, 0x06, 0xfb, 0x8d, 0x30, 0x7c, 0x9e, 0xdb,
	0x4b, 0x0f, 0x68, 0x05, 0xe3, 0x9f, 0x1e, 0x44, 0xef, 0xff, 0x61, 0x90, 0x1e, 0x41, 0x5f, 0xb1,
	0xb4, 0xae, 0x7e, 0x42, 0xcd, 0x01, 0xf3, 0xdb, 0x03, 0x76, 0x03, 0xa0, 0x37, 0x2c, 0xe1, 0xaa,
	0x91, 0x75, 0x83, 0xc1, 0x37, 0x4d, 0x5a, 0xe8, 0x3a, 0xdc, 0x0a, 0xa2, 0xa2, 0x5a, 0x49, 0x56,
	0x30, 0xfe, 0x04, 0xe1, 0x2c, 0x93, 0x86, 0x09, 0xc9, 0x15, 0x4e, 0xa9, 0xe2, 0x6b, 0xa1, 0x8d,
	0x3a, 0xda, 0x4c, 0x42, 0xea, 0x30, 0x79, 0x00, 0x3d, 0x91, 0xb2, 0x35, 0xb7, 0xdd, 0x86, 0xb4,
	0x04, 0x78, 0x31, 0x56, 0x98, 0x8d, 0xed, 0x34, 0xa4, 0xf6, 0x39, 0xfe, 0xd5, 0x81, 0x87, 0xae,
	0x66, 0x2b, 0x86, 0x17, 0x10, 0xae, 0x2a, 0xc1, 0x1e, 0x30, 0xbc, 0x8d, 0xa6, 0xb8, 0x85, 0xd3,
	0xda, 0x5f, 0x3b, 0xd0, 0xae, 0x0d, 0x53, 0xe6, 0x8b, 0x48, 0xcb, 0x63, 0x9d, 0x1d, 0x19, 0x6d,
	0x58, 0x9a, 0xd3, 0xda, 0x41, 0x9e, 0x42, 0xc0, 0x65, 0x62, 0xcd, 0xfe, 0x9f, 0xcd, 0x95, 0x5e,
	0xae, 0xe3, 0x69, 0x07, 0xdc, 0x3a, 0x9e, 0x56, 0xc0, 0x69, 0xec, 0x60, 0x63, 0x74, 0x1a, 0x3b,
	0xe0, 0x17, 0xb8, 0x63, 0x62, 0x5b, 0x28, 0x8e, 0x2a, 0x46, 0xd9, 0xa1, 0x0d, 0x06, 0x57, 0x82,
	0x7d, 0x67, 0x62, 0xcb, 0x96, 0x62, 0x2b, 0xcc, 0x11, 0xcb, 0x07, 0xd6, 0x74, 0x4e, 0xe3, 0x1a,
	0x2a, 0x66, 0x84, 0x5c, 0xa3, 0x67, 0x60, 0x3d, 0x35, 0x81, 0x3d, 0xe4, 0x4a, 0xac, 0xec, 0x29,
	0xa1, 0x15, 0x1d, 0x8e, 0xdf, 0x41, 0xf0, 0x46, 0x24, 0x73, 0xc3, 0x53, 0xf2, 0x0a, 0xc0, 0xa5,
	0xa5, 0xed, 0x70, 0x0d, 0x6f, 0x1f, 0x9f, 0x07, 0xda, 0xf8, 0x00, 0xb4, 0x61, 0x5f, 0xf6, 0xed,
	0xdf, 0xde, 0xcb, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xc6, 0xe4, 0xf4, 0x38, 0x1a, 0x05, 0x00,
	0x00,
}
